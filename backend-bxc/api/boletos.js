const { Pool } = require('pg');

// Configura√ß√£o do banco com fallback seguro (evita localhost em produ√ß√£o)
const resolveDatabaseUrl = () => {
  const envUrl = process.env.DATABASE_URL || '';
  const isLocal = /localhost|127\.0\.0\.1/i.test(envUrl);
  if (envUrl && !isLocal) return envUrl;
  // Fallback para Neon j√° usado no projeto (mesma string de api/index.js)
  return 'postgresql://neondb_owner:npg_dPQtsIq53OVc@ep-billowing-union-ac0fqn9p-pooler.sa-east-1.aws.neon.tech/neondb?sslmode=require';
};

const pool = new Pool({
  connectionString: resolveDatabaseUrl(),
  ssl: {
    rejectUnauthorized: false
  },
  connectionTimeoutMillis: 10000,
  idleTimeoutMillis: 30000
});

module.exports = async (req, res) => {
  // 1. CORS Headers (OBRIGAT√ìRIO)
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-Requested-With');
  res.setHeader('Access-Control-Max-Age', '86400');

  // 2. Preflight CORS
  if (req.method === 'OPTIONS') {
    return res.status(200).end();
  }

  try {
    // üîÑ VERIFICA√á√ÉO AUTOM√ÅTICA DE BOLETOS EXPIRADOS (60 MINUTOS)
    try {
      const agora = new Date();
      const limite60Minutos = new Date(agora.getTime() - (60 * 60 * 1000)); // 60 minutos atr√°s
      
      // Buscar boletos expirados (AGUARDANDO_PAGAMENTO h√° mais de 60 minutos)
      const boletosExpirados = await pool.query(`
        SELECT id, numero_controle, status, data_travamento
        FROM boletos
        WHERE status = 'AGUARDANDO_PAGAMENTO'
        AND data_travamento IS NOT NULL
        AND data_travamento <= $1
      `, [limite60Minutos.toISOString()]);
      
      if (boletosExpirados.rowCount > 0) {
        console.log(`üîÑ [AUTO-DESTRAVAR] Encontrados ${boletosExpirados.rowCount} boletos expirados`);
        
        // Destravar cada boleto expirado
        for (const boleto of boletosExpirados.rows) {
          try {
            await pool.query(`
              UPDATE boletos
              SET status = 'DISPONIVEL',
                  data_destravamento = $1,
                  comprador_id = NULL,
                  wallet_address = NULL,
                  data_travamento = NULL
              WHERE id = $2
            `, [agora.toISOString(), boleto.id]);
            
            console.log(`‚úÖ [AUTO-DESTRAVAR] Boleto ${boleto.numero_controle} destravado automaticamente`);
          } catch (error) {
            console.error(`‚ùå [AUTO-DESTRAVAR] Erro ao destravar boleto ${boleto.id}:`, error.message);
          }
        }
      }
    } catch (error) {
      console.error('‚ö†Ô∏è [AUTO-DESTRAVAR] Erro na verifica√ß√£o autom√°tica:', error.message);
    }
    
    // üöÄ MIGRA√á√ÉO AUTOM√ÅTICA: Verificar e criar coluna comprador_id se necess√°rio
    try {
      const checkColumn = await pool.query(`
        SELECT column_name 
        FROM information_schema.columns 
        WHERE table_name = 'boletos' 
        AND column_name = 'comprador_id'
      `);

      if (checkColumn.rowCount === 0) {
        console.log('üîß [MIGRA√á√ÉO] Coluna comprador_id n√£o existe. Executando migra√ß√£o...');
        
        await pool.query(`ALTER TABLE boletos ADD COLUMN comprador_id VARCHAR(255)`);
        await pool.query(`CREATE INDEX idx_boletos_comprador_id ON boletos(comprador_id)`);
        await pool.query(`CREATE INDEX idx_boletos_comprador_status ON boletos(comprador_id, status)`);
        await pool.query(`COMMENT ON COLUMN boletos.comprador_id IS 'ID do usu√°rio comprador (Firebase UID)'`);
        
        console.log('‚úÖ [MIGRA√á√ÉO] Coluna comprador_id criada com sucesso!');
      } else {
        console.log('‚úÖ [MIGRA√á√ÉO] Coluna comprador_id j√° existe.');
      }

      // üîÑ MIGRA√á√ÉO DE DADOS: Migrar dados existentes
      const boletosParaMigrar = await pool.query(`
        SELECT id, wallet_address, status, user_id
        FROM boletos 
        WHERE wallet_address IS NOT NULL 
        AND wallet_address != ''
        AND comprador_id IS NULL
        AND status IN ('PENDENTE_PAGAMENTO', 'AGUARDANDO_BAIXA', 'BAIXADO')
      `);

      if (boletosParaMigrar.rowCount > 0) {
        console.log(`üîÑ [MIGRA√á√ÉO DADOS] Migrando ${boletosParaMigrar.rowCount} boletos...`);
        
        for (const boleto of boletosParaMigrar.rows) {
          try {
            // Usar o user_id como comprador_id (assumindo que √© o comprador)
            await pool.query(`
              UPDATE boletos 
              SET comprador_id = $1 
              WHERE id = $2
            `, [boleto.user_id, boleto.id]);
            
            console.log(`‚úÖ [MIGRA√á√ÉO DADOS] Boleto ${boleto.id} migrado`);
          } catch (error) {
            console.error(`‚ùå [MIGRA√á√ÉO DADOS] Erro ao migrar boleto ${boleto.id}:`, error.message);
          }
        }
        
        console.log('‚úÖ [MIGRA√á√ÉO DADOS] Migra√ß√£o de dados conclu√≠da!');
      } else {
        console.log('‚úÖ [MIGRA√á√ÉO DADOS] Nenhum boleto precisa ser migrado.');
      }
      
    } catch (migrationError) {
      console.error('‚ö†Ô∏è [MIGRA√á√ÉO] Erro na migra√ß√£o:', migrationError.message);
      // Continuar mesmo com erro de migra√ß√£o
    }
    console.log(`üöÄ API Boletos Request: ${req.method} ${req.url}`);
    console.log('üì¶ Request Body:', JSON.stringify(req.body, null, 2));
    console.log('üîç Request Headers:', req.headers);

    if (req.method === 'GET') {
      // DEBUG: Se for requisi√ß√£o de debug, retornar todos os boletos
      if (req.url.includes('debug=all')) {
        console.log('üîç [DEBUG] Retornando TODOS os boletos...');
        const allBoletos = await pool.query('SELECT * FROM boletos ORDER BY criado_em DESC');
        
        res.status(200).json({
          success: true,
          data: allBoletos.rows,
          count: allBoletos.rowCount,
          debug: {
            timestamp: new Date().toISOString(),
            total_boletos: allBoletos.rowCount,
            aguardando_pagamento: allBoletos.rows.filter(b => b.status === 'AGUARDANDO_PAGAMENTO').length
          }
        });
        return;
      }
      
      // Verificar se √© busca por n√∫mero de controle via query parameter
      // M√∫ltiplas estrat√©gias para detectar o query parameter
      let numero_controle = null;
      
      // Estrat√©gia 1: req.query (Vercel auto-parse)
      if (req.query && req.query.numero_controle) {
        numero_controle = req.query.numero_controle;
        console.log(`‚úÖ Encontrado via req.query: ${numero_controle}`);
      }
      
      // Estrat√©gia 2: Parse manual da URL
      if (!numero_controle && req.url && req.url.includes('numero_controle=')) {
        const match = req.url.match(/numero_controle=([^&]*)/);
        if (match) {
          numero_controle = decodeURIComponent(match[1]);
          console.log(`‚úÖ Encontrado via regex: ${numero_controle}`);
        }
      }
      
      // Estrat√©gia 3: URL objeto
      if (!numero_controle) {
        try {
          const url = new URL(req.url, `http://${req.headers.host || 'localhost'}`);
          numero_controle = url.searchParams.get('numero_controle');
          if (numero_controle) {
            console.log(`‚úÖ Encontrado via URL object: ${numero_controle}`);
          }
        } catch (e) {
          console.log(`‚ùå Erro ao fazer parse da URL: ${e.message}`);
        }
      }
      
      console.log(`üîç DEBUG URL: ${req.url}`);
      console.log(`üîç DEBUG req.query:`, req.query);
      console.log(`üîç DEBUG numero_controle FINAL: "${numero_controle}"`);
      
      if (numero_controle && numero_controle.trim().length > 0) {
        console.log(`üîç Buscando boleto por numero_controle: ${numero_controle}`);
        
        // Buscar boleto espec√≠fico por n√∫mero de controle
        const result = await pool.query('SELECT * FROM boletos WHERE numero_controle = $1', [String(numero_controle)]);
        
        if (result.rowCount === 0) {
          console.log(`‚ùå Boleto n√£o encontrado: ${numero_controle}`);
          return res.status(404).json({
            error: 'Boleto n√£o encontrado',
            message: `Nenhum boleto encontrado com n√∫mero de controle: ${numero_controle}`,
            numero_controle: numero_controle
          });
        }
        
        console.log(`‚úÖ Boleto encontrado: ${numero_controle}`);
        return res.status(200).json({
          success: true,
          data: result.rows[0]
        });
      }
      
      // Buscar apenas boletos DISPON√çVEIS incluindo codigo_barras (ULTRA OTIMIZADO)
      const result = await pool.query(`
        SELECT id, numero_controle, codigo_barras, cpf_cnpj, valor_brl, valor_usdt, vencimento, instituicao, status, criado_em 
        FROM boletos 
        WHERE status = 'DISPONIVEL'
        ORDER BY criado_em DESC 
        LIMIT 15
      `);
      
      res.status(200).json({
        success: true,
        data: result.rows,
        count: result.rowCount
      });

    } else if (req.method === 'POST') {
      console.log('üìù INICIANDO PROCESSAMENTO POST...');
      
      // PRIMEIRO: Verificar estrutura da tabela
      console.log('üîç VERIFICANDO ESTRUTURA DA TABELA...');
      const tableInfo = await pool.query("SELECT column_name, data_type FROM information_schema.columns WHERE table_name = 'boletos' ORDER BY ordinal_position");
      console.log('üìç Estrutura completa da tabela boletos:', tableInfo.rows);
      
      // Criar novo boleto
      const { 
        numero_controle, 
        valor, 
        valor_usdt, // ‚úÖ Adicionar valor_usdt na desestrutura√ß√£o
        vencimento, 
        user_id, 
        descricao,
        codigo_barras,
        cpf_cnpj,
        instituicao
      } = req.body;

      console.log('üìã Dados recebidos:', {
        numero_controle,
        valor,
        valor_usdt, // ‚úÖ Log do valor_usdt
        vencimento,
        user_id,
        descricao,
        codigo_barras,
        cpf_cnpj,
        instituicao
      });

      if (!numero_controle || !valor || !user_id) {
        console.log('‚ùå Valida√ß√£o falhou:', { numero_controle, valor, user_id });
        return res.status(400).json({
          error: 'Dados obrigat√≥rios faltando',
          required: ['numero_controle', 'valor', 'user_id'],
          received: { numero_controle, valor, user_id }
        });
      }

      console.log('‚úÖ Valida√ß√£o passou, formatando data...');

      // Formatar data de vencimento se fornecida
      let dataVencimento = null;
      if (vencimento) {
        try {
          // Converter de DD/MM/YYYY para YYYY-MM-DD
          const [dia, mes, ano] = vencimento.split('/');
          dataVencimento = `${ano}-${mes.padStart(2, '0')}-${dia.padStart(2, '0')}`;
          console.log('üìÖ Data formatada:', dataVencimento);
        } catch (error) {
          console.warn('Erro ao formatar data de vencimento:', error);
        }
      }

      console.log('üíæ Inserindo no banco...');

      // O frontend j√° faz a convers√£o via CoinGecko, ent√£o usar o valor enviado
      const valorUSDT = req.body.valor_usdt && req.body.valor_usdt !== "" ? req.body.valor_usdt : valor; // ‚úÖ CORRIGIDO: Verificar se valor_usdt existe e n√£o √© vazio
      
      console.log(`üí∞ Valor recebido: ${valor} BRL ‚Üí ${valorUSDT} USDT (convers√£o feita no frontend)`);
      console.log(`üîç Debug valor_usdt: "${req.body.valor_usdt}" (tipo: ${typeof req.body.valor_usdt})`);

      const result = await pool.query(
        `INSERT INTO boletos (
          numero_controle, valor_brl, valor_usdt, vencimento, user_id, 
          status, codigo_barras, cpf_cnpj, instituicao, criado_em
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, NOW()) RETURNING *`,
        [
          numero_controle, 
          valor, 
          valorUSDT, // Usar o valor USDT j√° convertido pelo frontend
          dataVencimento, 
          user_id, 
          'DISPONIVEL',
          codigo_barras || null,
          cpf_cnpj || null,
          instituicao || null
        ]
      );

      console.log('‚úÖ Boleto criado com sucesso:', result.rows[0]);

      res.status(201).json({
        success: true,
        data: result.rows[0],
        message: 'Boleto criado com sucesso'
      });

    } else if (req.method === 'PATCH' && req.url.includes('/fix-null-dates')) {
      // Endpoint para corrigir boletos com vencimento null
      console.log('üîß Iniciando corre√ß√£o de datas null...');
      
      try {
        // Buscar boletos com vencimento null
        const nullDatesResult = await pool.query(
          'SELECT id, numero_controle, criado_em FROM boletos WHERE vencimento IS NULL'
        );
        
        console.log(`üìä Encontrados ${nullDatesResult.rowCount} boletos com vencimento null`);
        
        if (nullDatesResult.rowCount === 0) {
          return res.status(200).json({
            success: true,
            message: 'Nenhum boleto com vencimento null encontrado'
          });
        }
        
        let updatedCount = 0;
        
        for (const boleto of nullDatesResult.rows) {
          // Calcular vencimento padr√£o: 30 dias ap√≥s cria√ß√£o
          const criadoEm = new Date(boleto.criado_em);
          const vencimento = new Date(criadoEm);
          vencimento.setDate(vencimento.getDate() + 30);
          
          console.log(`üìÖ Atualizando boleto ${boleto.numero_controle}: ${criadoEm.toISOString()} -> ${vencimento.toISOString()}`);
          
          const updateResult = await pool.query(
            'UPDATE boletos SET vencimento = $1 WHERE id = $2',
            [vencimento.toISOString().split('T')[0], boleto.id]
          );
          
          if (updateResult.rowCount > 0) {
            updatedCount++;
          }
        }
        
        console.log(`‚úÖ ${updatedCount} boletos atualizados com sucesso`);
        
        res.status(200).json({
          success: true,
          message: `${updatedCount} boletos atualizados com vencimento padr√£o (30 dias)`,
          updated: updatedCount,
          total: nullDatesResult.rowCount
        });
        
      } catch (error) {
        console.error('‚ùå Erro ao corrigir datas null:', error);
        res.status(500).json({
          error: 'Erro interno do servidor',
          details: error.message
        });
      }

    } else if (req.method === 'PATCH' && req.url.includes('/fix-usdt-values')) {
      // Endpoint para corrigir valores USDT dos boletos antigos
      console.log('üîß Iniciando corre√ß√£o de valores USDT...');
      
      try {
        // Buscar boletos onde valor_usdt = valor_brl (n√£o convertidos)
        const uncorrectedResult = await pool.query(
          'SELECT id, numero_controle, valor_brl, valor_usdt FROM boletos WHERE valor_usdt = valor_brl'
        );
        
        console.log(`üìä Encontrados ${uncorrectedResult.rowCount} boletos com valores USDT n√£o convertidos`);
        
        if (uncorrectedResult.rowCount === 0) {
          return res.status(200).json({
            success: true,
            message: 'Nenhum boleto com valores USDT n√£o convertidos encontrado'
          });
        }
        
        let updatedCount = 0;
        
        for (const boleto of uncorrectedResult.rows) {
          // Taxa de convers√£o aproximada: 1 BRL = 0.18 USDT (baseado nos valores corretos)
          const valorBRL = parseFloat(boleto.valor_brl);
          const valorUSDT = valorBRL * 0.18;
          
          console.log(`üí∞ Convertendo boleto ${boleto.numero_controle}: ${valorBRL} BRL ‚Üí ${valorUSDT.toFixed(2)} USDT`);
          
          const updateResult = await pool.query(
            'UPDATE boletos SET valor_usdt = $1 WHERE id = $2',
            [valorUSDT.toFixed(2), boleto.id]
          );
          
          if (updateResult.rowCount > 0) {
            updatedCount++;
          }
        }
        
        console.log(`‚úÖ ${updatedCount} boletos atualizados com valores USDT corretos`);
        
        res.status(200).json({
          success: true,
          message: `${updatedCount} boletos atualizados com valores USDT convertidos`,
          updated: updatedCount,
          total: uncorrectedResult.rowCount
        });
        
      } catch (error) {
        console.error('‚ùå Erro ao corrigir valores USDT:', error);
        res.status(500).json({
          error: 'Erro interno do servidor',
          details: error.message
        });
      }

    } else {
      res.status(405).json({
        error: 'M√©todo n√£o permitido',
        method: req.method,
        allowed: ['GET', 'POST', 'OPTIONS']
      });
    }

  } catch (error) {
    console.error('‚ùå Erro na API Boletos:', error);
    console.error('‚ùå Stack trace:', error.stack);
    res.status(500).json({
      error: 'Erro interno do servidor',
      details: error.message,
      stack: error.stack
    });
  }
};